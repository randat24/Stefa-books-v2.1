"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/books/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/logger.ts":
/*!***************************!*\
  !*** ./src/lib/logger.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   logger: function() { return /* binding */ logger; }\n/* harmony export */ });\nclass Logger {\n    formatMessage(level, message, context) {\n        const timestamp = new Date().toISOString();\n        const contextStr = context ? \"[\".concat(context, \"]\") : \"\";\n        return \"[\".concat(timestamp, \"] \").concat(level.toUpperCase(), \" \").concat(contextStr, \" \").concat(message);\n    }\n    shouldLog(level) {\n        return this.enabledLevels.has(level);\n    }\n    debug(message, data, context) {\n        if (this.shouldLog(\"debug\")) {\n            const formatted = this.formatMessage(\"debug\", message, context);\n            if (data) {\n                console.debug(formatted, data);\n            } else {\n                console.debug(formatted);\n            }\n        }\n    }\n    info(message, data, context) {\n        if (this.shouldLog(\"info\")) {\n            const formatted = this.formatMessage(\"info\", message, context);\n            if (data) {\n                console.info(formatted, data);\n            } else {\n                console.info(formatted);\n            }\n        }\n    }\n    warn(message, data, context) {\n        if (this.shouldLog(\"warn\")) {\n            const formatted = this.formatMessage(\"warn\", message, context);\n            if (data) {\n                console.warn(formatted, data);\n            } else {\n                console.warn(formatted);\n            }\n        }\n    }\n    error(message, error, context) {\n        if (this.shouldLog(\"error\")) {\n            const formatted = this.formatMessage(\"error\", message, context);\n            if (error) {\n                console.error(formatted, error);\n            } else {\n                console.error(formatted);\n            }\n        }\n    }\n    search(message, data) {\n        this.debug(message, data, \"Search\");\n    }\n    analytics(message, data) {\n        this.debug(message, data, \"Analytics\");\n    }\n    storage(message, error) {\n        this.warn(message, error, \"Storage\");\n    }\n    constructor(){\n        this.isDevelopment = \"development\" === \"development\";\n        this.enabledLevels = new Set([\n            \"info\",\n            \"warn\",\n            \"error\"\n        ]);\n        if (this.isDevelopment) {\n            this.enabledLevels.add(\"debug\");\n        }\n    }\n}\nconst logger = new Logger();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dCI6WyJ0eXBlIExvZ0xldmVsID0gJ2RlYnVnJyB8ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvcic7XG5cbmludGVyZmFjZSBMb2dFbnRyeSB7XG4gIGxldmVsOiBMb2dMZXZlbDtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBkYXRhPzogYW55O1xuICB0aW1lc3RhbXA6IHN0cmluZztcbiAgY29udGV4dD86IHN0cmluZztcbn1cblxuY2xhc3MgTG9nZ2VyIHtcbiAgcHJpdmF0ZSBpc0RldmVsb3BtZW50ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCc7XG4gIHByaXZhdGUgZW5hYmxlZExldmVsczogU2V0PExvZ0xldmVsPiA9IG5ldyBTZXQoWydpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuaXNEZXZlbG9wbWVudCkge1xuICAgICAgdGhpcy5lbmFibGVkTGV2ZWxzLmFkZCgnZGVidWcnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZvcm1hdE1lc3NhZ2UobGV2ZWw6IExvZ0xldmVsLCBtZXNzYWdlOiBzdHJpbmcsIGNvbnRleHQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBjb250ZXh0U3RyID0gY29udGV4dCA/IGBbJHtjb250ZXh0fV1gIDogJyc7XG4gICAgcmV0dXJuIGBbJHt0aW1lc3RhbXB9XSAke2xldmVsLnRvVXBwZXJDYXNlKCl9ICR7Y29udGV4dFN0cn0gJHttZXNzYWdlfWA7XG4gIH1cblxuICBwcml2YXRlIHNob3VsZExvZyhsZXZlbDogTG9nTGV2ZWwpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVkTGV2ZWxzLmhhcyhsZXZlbCk7XG4gIH1cblxuICBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcsIGRhdGE/OiBhbnksIGNvbnRleHQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2coJ2RlYnVnJykpIHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0TWVzc2FnZSgnZGVidWcnLCBtZXNzYWdlLCBjb250ZXh0KTtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoZm9ybWF0dGVkLCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoZm9ybWF0dGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbmZvKG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IGFueSwgY29udGV4dD86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNob3VsZExvZygnaW5mbycpKSB7XG4gICAgICBjb25zdCBmb3JtYXR0ZWQgPSB0aGlzLmZvcm1hdE1lc3NhZ2UoJ2luZm8nLCBtZXNzYWdlLCBjb250ZXh0KTtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhmb3JtYXR0ZWQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5pbmZvKGZvcm1hdHRlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd2FybihtZXNzYWdlOiBzdHJpbmcsIGRhdGE/OiBhbnksIGNvbnRleHQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2coJ3dhcm4nKSkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRNZXNzYWdlKCd3YXJuJywgbWVzc2FnZSwgY29udGV4dCk7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZm9ybWF0dGVkLCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihmb3JtYXR0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVycm9yKG1lc3NhZ2U6IHN0cmluZywgZXJyb3I/OiBhbnksIGNvbnRleHQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2coJ2Vycm9yJykpIHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0TWVzc2FnZSgnZXJyb3InLCBtZXNzYWdlLCBjb250ZXh0KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdHRlZCwgZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXR0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNlYXJjaChtZXNzYWdlOiBzdHJpbmcsIGRhdGE/OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmRlYnVnKG1lc3NhZ2UsIGRhdGEsICdTZWFyY2gnKTtcbiAgfVxuXG4gIGFuYWx5dGljcyhtZXNzYWdlOiBzdHJpbmcsIGRhdGE/OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmRlYnVnKG1lc3NhZ2UsIGRhdGEsICdBbmFseXRpY3MnKTtcbiAgfVxuXG4gIHN0b3JhZ2UobWVzc2FnZTogc3RyaW5nLCBlcnJvcj86IGFueSk6IHZvaWQge1xuICAgIHRoaXMud2FybihtZXNzYWdlLCBlcnJvciwgJ1N0b3JhZ2UnKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcigpOyJdLCJuYW1lcyI6WyJMb2dnZXIiLCJmb3JtYXRNZXNzYWdlIiwibGV2ZWwiLCJtZXNzYWdlIiwiY29udGV4dCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNvbnRleHRTdHIiLCJ0b1VwcGVyQ2FzZSIsInNob3VsZExvZyIsImVuYWJsZWRMZXZlbHMiLCJoYXMiLCJkZWJ1ZyIsImRhdGEiLCJmb3JtYXR0ZWQiLCJjb25zb2xlIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsInNlYXJjaCIsImFuYWx5dGljcyIsInN0b3JhZ2UiLCJjb25zdHJ1Y3RvciIsImlzRGV2ZWxvcG1lbnQiLCJwcm9jZXNzIiwiU2V0IiwiYWRkIiwibG9nZ2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/logger.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/recentViews.ts":
/*!********************************!*\
  !*** ./src/lib/recentViews.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToRecentViews: function() { return /* binding */ addToRecentViews; },\n/* harmony export */   clearRecentViews: function() { return /* binding */ clearRecentViews; },\n/* harmony export */   getRecentViews: function() { return /* binding */ getRecentViews; },\n/* harmony export */   removeFromRecentViews: function() { return /* binding */ removeFromRecentViews; }\n/* harmony export */ });\n/* harmony import */ var _lib_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/logger */ \"(app-pages-browser)/./src/lib/logger.ts\");\n/* __next_internal_client_entry_do_not_use__ getRecentViews,addToRecentViews,clearRecentViews,removeFromRecentViews auto */ \nconst STORAGE_KEY = \"stefa_recent_views\";\nconst MAX_RECENT_VIEWS = 10;\n// Get recent views from localStorage\nfunction getRecentViews() {\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(STORAGE_KEY);\n        if (!stored) return [];\n        const parsed = JSON.parse(stored);\n        return Array.isArray(parsed) ? parsed : [];\n    } catch (e) {\n        return [];\n    }\n}\n// Add a book to recent views\nfunction addToRecentViews(bookId) {\n    if (false) {}\n    try {\n        const current = getRecentViews();\n        // Remove if already exists to avoid duplicates\n        const filtered = current.filter((id)=>id !== bookId);\n        // Add to front of array\n        const updated = [\n            bookId,\n            ...filtered\n        ];\n        // Limit to max items\n        const limited = updated.slice(0, MAX_RECENT_VIEWS);\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(limited));\n        // Dispatch custom event for components to listen to\n        window.dispatchEvent(new CustomEvent(\"recentViewsUpdated\", {\n            detail: {\n                bookId,\n                recentViews: limited\n            }\n        }));\n    } catch (error) {\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__.logger.storage(\"Failed to update recent views\", error);\n    }\n}\n// Clear all recent views\nfunction clearRecentViews() {\n    if (false) {}\n    try {\n        localStorage.removeItem(STORAGE_KEY);\n        window.dispatchEvent(new CustomEvent(\"recentViewsUpdated\", {\n            detail: {\n                recentViews: []\n            }\n        }));\n    } catch (error) {\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__.logger.storage(\"Failed to clear recent views\", error);\n    }\n}\n// Remove specific book from recent views\nfunction removeFromRecentViews(bookId) {\n    if (false) {}\n    try {\n        const current = getRecentViews();\n        const updated = current.filter((id)=>id !== bookId);\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));\n        window.dispatchEvent(new CustomEvent(\"recentViewsUpdated\", {\n            detail: {\n                bookId,\n                recentViews: updated\n            }\n        }));\n    } catch (error) {\n        _lib_logger__WEBPACK_IMPORTED_MODULE_0__.logger.storage(\"Failed to remove from recent views\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcmVjZW50Vmlld3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7NEhBR3NDO0FBRXRDLE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsbUJBQW1CO0FBRXpCLHFDQUFxQztBQUM5QixTQUFTQztJQUNkLElBQUksS0FBNkIsRUFBRSxFQUFVO0lBRTdDLElBQUk7UUFDRixNQUFNQyxTQUFTQyxhQUFhQyxPQUFPLENBQUNMO1FBQ3BDLElBQUksQ0FBQ0csUUFBUSxPQUFPLEVBQUU7UUFFdEIsTUFBTUcsU0FBU0MsS0FBS0MsS0FBSyxDQUFDTDtRQUMxQixPQUFPTSxNQUFNQyxPQUFPLENBQUNKLFVBQVVBLFNBQVMsRUFBRTtJQUM1QyxFQUFFLFVBQU07UUFDTixPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRUEsNkJBQTZCO0FBQ3RCLFNBQVNLLGlCQUFpQkMsTUFBYztJQUM3QyxJQUFJLEtBQTZCLEVBQUUsRUFBTztJQUUxQyxJQUFJO1FBQ0YsTUFBTUMsVUFBVVg7UUFFaEIsK0NBQStDO1FBQy9DLE1BQU1ZLFdBQVdELFFBQVFFLE1BQU0sQ0FBQ0MsQ0FBQUEsS0FBTUEsT0FBT0o7UUFFN0Msd0JBQXdCO1FBQ3hCLE1BQU1LLFVBQVU7WUFBQ0w7ZUFBV0U7U0FBUztRQUVyQyxxQkFBcUI7UUFDckIsTUFBTUksVUFBVUQsUUFBUUUsS0FBSyxDQUFDLEdBQUdsQjtRQUVqQ0csYUFBYWdCLE9BQU8sQ0FBQ3BCLGFBQWFPLEtBQUtjLFNBQVMsQ0FBQ0g7UUFFakQsb0RBQW9EO1FBQ3BESSxPQUFPQyxhQUFhLENBQUMsSUFBSUMsWUFBWSxzQkFBc0I7WUFDekRDLFFBQVE7Z0JBQUViO2dCQUFRYyxhQUFhUjtZQUFRO1FBQ3pDO0lBQ0YsRUFBRSxPQUFPUyxPQUFPO1FBQ2Q1QiwrQ0FBTUEsQ0FBQzZCLE9BQU8sQ0FBQyxpQ0FBaUNEO0lBQ2xEO0FBQ0Y7QUFFQSx5QkFBeUI7QUFDbEIsU0FBU0U7SUFDZCxJQUFJLEtBQTZCLEVBQUUsRUFBTztJQUUxQyxJQUFJO1FBQ0Z6QixhQUFhMEIsVUFBVSxDQUFDOUI7UUFDeEJzQixPQUFPQyxhQUFhLENBQUMsSUFBSUMsWUFBWSxzQkFBc0I7WUFDekRDLFFBQVE7Z0JBQUVDLGFBQWEsRUFBRTtZQUFDO1FBQzVCO0lBQ0YsRUFBRSxPQUFPQyxPQUFPO1FBQ2Q1QiwrQ0FBTUEsQ0FBQzZCLE9BQU8sQ0FBQyxnQ0FBZ0NEO0lBQ2pEO0FBQ0Y7QUFFQSx5Q0FBeUM7QUFDbEMsU0FBU0ksc0JBQXNCbkIsTUFBYztJQUNsRCxJQUFJLEtBQTZCLEVBQUUsRUFBTztJQUUxQyxJQUFJO1FBQ0YsTUFBTUMsVUFBVVg7UUFDaEIsTUFBTWUsVUFBVUosUUFBUUUsTUFBTSxDQUFDQyxDQUFBQSxLQUFNQSxPQUFPSjtRQUU1Q1IsYUFBYWdCLE9BQU8sQ0FBQ3BCLGFBQWFPLEtBQUtjLFNBQVMsQ0FBQ0o7UUFDakRLLE9BQU9DLGFBQWEsQ0FBQyxJQUFJQyxZQUFZLHNCQUFzQjtZQUN6REMsUUFBUTtnQkFBRWI7Z0JBQVFjLGFBQWFUO1lBQVE7UUFDekM7SUFDRixFQUFFLE9BQU9VLE9BQU87UUFDZDVCLCtDQUFNQSxDQUFDNkIsT0FBTyxDQUFDLHNDQUFzQ0Q7SUFDdkQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3JlY2VudFZpZXdzLnRzPzhmMGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB0eXBlIHsgQm9vayB9IGZyb20gXCJAL2xpYi90eXBlc1wiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIkAvbGliL2xvZ2dlclwiO1xuXG5jb25zdCBTVE9SQUdFX0tFWSA9IFwic3RlZmFfcmVjZW50X3ZpZXdzXCI7XG5jb25zdCBNQVhfUkVDRU5UX1ZJRVdTID0gMTA7XG5cbi8vIEdldCByZWNlbnQgdmlld3MgZnJvbSBsb2NhbFN0b3JhZ2VcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWNlbnRWaWV3cygpOiBCb29rW1wiaWRcIl1bXSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gW107XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKTtcbiAgICBpZiAoIXN0b3JlZCkgcmV0dXJuIFtdO1xuICAgIFxuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXJzZWQpID8gcGFyc2VkIDogW107XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vLyBBZGQgYSBib29rIHRvIHJlY2VudCB2aWV3c1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFRvUmVjZW50Vmlld3MoYm9va0lkOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgY3VycmVudCA9IGdldFJlY2VudFZpZXdzKCk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIGlmIGFscmVhZHkgZXhpc3RzIHRvIGF2b2lkIGR1cGxpY2F0ZXNcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGN1cnJlbnQuZmlsdGVyKGlkID0+IGlkICE9PSBib29rSWQpO1xuICAgIFxuICAgIC8vIEFkZCB0byBmcm9udCBvZiBhcnJheVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBbYm9va0lkLCAuLi5maWx0ZXJlZF07XG4gICAgXG4gICAgLy8gTGltaXQgdG8gbWF4IGl0ZW1zXG4gICAgY29uc3QgbGltaXRlZCA9IHVwZGF0ZWQuc2xpY2UoMCwgTUFYX1JFQ0VOVF9WSUVXUyk7XG4gICAgXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGxpbWl0ZWQpKTtcbiAgICBcbiAgICAvLyBEaXNwYXRjaCBjdXN0b20gZXZlbnQgZm9yIGNvbXBvbmVudHMgdG8gbGlzdGVuIHRvXG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwicmVjZW50Vmlld3NVcGRhdGVkXCIsIHsgXG4gICAgICBkZXRhaWw6IHsgYm9va0lkLCByZWNlbnRWaWV3czogbGltaXRlZCB9XG4gICAgfSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5zdG9yYWdlKFwiRmFpbGVkIHRvIHVwZGF0ZSByZWNlbnQgdmlld3NcIiwgZXJyb3IpO1xuICB9XG59XG5cbi8vIENsZWFyIGFsbCByZWNlbnQgdmlld3NcbmV4cG9ydCBmdW5jdGlvbiBjbGVhclJlY2VudFZpZXdzKCk6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICBcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0tFWSk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwicmVjZW50Vmlld3NVcGRhdGVkXCIsIHsgXG4gICAgICBkZXRhaWw6IHsgcmVjZW50Vmlld3M6IFtdIH1cbiAgICB9KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLnN0b3JhZ2UoXCJGYWlsZWQgdG8gY2xlYXIgcmVjZW50IHZpZXdzXCIsIGVycm9yKTtcbiAgfVxufVxuXG4vLyBSZW1vdmUgc3BlY2lmaWMgYm9vayBmcm9tIHJlY2VudCB2aWV3c1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUZyb21SZWNlbnRWaWV3cyhib29rSWQ6IHN0cmluZyk6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICBcbiAgdHJ5IHtcbiAgICBjb25zdCBjdXJyZW50ID0gZ2V0UmVjZW50Vmlld3MoKTtcbiAgICBjb25zdCB1cGRhdGVkID0gY3VycmVudC5maWx0ZXIoaWQgPT4gaWQgIT09IGJvb2tJZCk7XG4gICAgXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWQpKTtcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJyZWNlbnRWaWV3c1VwZGF0ZWRcIiwgeyBcbiAgICAgIGRldGFpbDogeyBib29rSWQsIHJlY2VudFZpZXdzOiB1cGRhdGVkIH1cbiAgICB9KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLnN0b3JhZ2UoXCJGYWlsZWQgdG8gcmVtb3ZlIGZyb20gcmVjZW50IHZpZXdzXCIsIGVycm9yKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJsb2dnZXIiLCJTVE9SQUdFX0tFWSIsIk1BWF9SRUNFTlRfVklFV1MiLCJnZXRSZWNlbnRWaWV3cyIsInN0b3JlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJBcnJheSIsImlzQXJyYXkiLCJhZGRUb1JlY2VudFZpZXdzIiwiYm9va0lkIiwiY3VycmVudCIsImZpbHRlcmVkIiwiZmlsdGVyIiwiaWQiLCJ1cGRhdGVkIiwibGltaXRlZCIsInNsaWNlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsInJlY2VudFZpZXdzIiwiZXJyb3IiLCJzdG9yYWdlIiwiY2xlYXJSZWNlbnRWaWV3cyIsInJlbW92ZUl0ZW0iLCJyZW1vdmVGcm9tUmVjZW50Vmlld3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/recentViews.ts\n"));

/***/ })

});